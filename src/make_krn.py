
#!/usr/bin/env python3
import numpy as np
import argparse

def load_mesh(npz_file):
    """Load nodes and tet connectivity (+ mat_id) from mesh .npz produced by mesh.py."""
    data = np.load(npz_file)
    knt = data['knt']              # (N,3) node coordinates
    ijk = data['ijk']              # (E,5): 4 node indices + mat_id (1..G)
    conn = ijk[:, :4].astype(np.int64)
    mat_id = ijk[:, 4].astype(np.int64)
    return knt, conn, mat_id

def compute_tetra_volumes(knt, conn):
    """Vectorized tet volume computation: V = |det([p1-p0, p2-p0, p3-p0])| / 6."""
    p0 = knt[conn[:, 0]]
    p1 = knt[conn[:, 1]]
    p2 = knt[conn[:, 2]]
    p3 = knt[conn[:, 3]]
    cross12 = np.cross(p1 - p0, p2 - p0)                 # (E,3)
    triple = np.einsum('ij,ij->i', cross12, p3 - p0)     # (E,)
    vols = np.abs(triple) / 6.0
    return vols

def generate_random_easy_axes(num_grains, rng):
    """
    Generate random easy axes uniformly on the sphere.
    Returns array shape (num_grains, 5): [theta, phi, x, y, z].
    """
    phi = rng.uniform(0.0, 2.0 * np.pi, size=num_grains)     # azimuth
    u = rng.uniform(-1.0, 1.0, size=num_grains)              # cos(theta)
    theta = np.arccos(u)                                     # polar

    st = np.sin(theta)
    x = st * np.cos(phi)
    y = st * np.sin(phi)
    z = u
    return np.column_stack((theta, phi, x, y, z))

def adjust_axes_sign(easy_axes, component):
    """
    Flip the vector (x,y,z) per grain so the requested component becomes > 0.
    component in {'x','y','z'}.
    """
    comp_idx = {'x': 2, 'y': 3, 'z': 4}[component]
    flip_mask = easy_axes[:, comp_idx] < 0.0
    # Flip x,y,z for grains where component < 0
    easy_axes[flip_mask, 2:5] *= -1.0
    # Note: theta, phi are kept as initially drawn (they encode the unflipped orientation).
    # loop.py only uses theta, phi to build the easy axis; flipping is realized by sign of x,y,z.
    return easy_axes

def volume_weighted_average_component(easy_axes, mat_id, vols, component):
    """
    Compute <m_component>_V = sum_e V_e * m_comp(grain_id(e)) / sum_e V_e,
    where m_comp for each grain comes from easy_axes after sign adjustment.
    """
    comp_idx = {'x': 2, 'y': 3, 'z': 4}[component]
    m_g = easy_axes[:, comp_idx]          # (G,)
    # Map each element to its grain's component: mat_id is 1..G
    m_e = m_g[mat_id - 1]                 # (E,)
    vw = np.sum(vols * m_e) / np.sum(vols)
    return vw

def generate_distribution_all_three(knt, conn, mat_id, tol, max_attempts, seed=None):
    """
    Loop:
      1) generate_random_easy_axes
      2) adjust for x -> avg_x; adjust for y -> avg_y; adjust for z -> avg_z
      3) if all |avg_* - 0.5| < tol -> accept; else repeat.
    Returns the accepted easy_axes (theta, phi only are written into .krn).
    """
    rng = np.random.default_rng(seed)
    vols = compute_tetra_volumes(knt, conn)
    num_grains = int(mat_id.max())  # since there is NO air, mat_id in 1..G

    for attempt in range(1, max_attempts + 1):
        easy_axes = generate_random_easy_axes(num_grains, rng)

        # Adjust for x ≥ 0 and compute <mx>_V
        easy_axes = adjust_axes_sign(easy_axes, 'x')
        avg_x = volume_weighted_average_component(easy_axes, mat_id, vols, 'x')

        # Adjust for y ≥ 0 and compute <my>_V
        easy_axes = adjust_axes_sign(easy_axes, 'y')
        avg_y = volume_weighted_average_component(easy_axes, mat_id, vols, 'y')

        # Adjust for z ≥ 0 and compute <mz>_V
        easy_axes = adjust_axes_sign(easy_axes, 'z')
        avg_z = volume_weighted_average_component(easy_axes, mat_id, vols, 'z')

        if (abs(avg_x - 0.5) < tol) and (abs(avg_y - 0.5) < tol) and (abs(avg_z - 0.5) < tol):
            print(f"[ok] Accepted after {attempt} attempt(s): "
                  f"<mx>_V={avg_x:.4f}, <my>_V={avg_y:.4f}, <mz>_V={avg_z:.4f}")
            return easy_axes, (avg_x, avg_y, avg_z), attempt

    raise RuntimeError(f"Failed to satisfy all three averages within tol={tol} after {max_attempts} attempts.")

def write_krn(path, easy_axes, K1, Js, A, summary=None):
    """
    Write .krn with columns: theta phi K1 dummy Js A
    Optionally include a comment header with summary.
    """
    with open(path, "w", encoding="utf-8") as f:
        if summary is not None:
            avg_x, avg_y, avg_z, attempts = summary
            f.write(f"# Generated by make_krn.py\n")
            f.write(f"# Attempts: {attempts}\n")
            f.write(f"# Volume-averaged <mx>={avg_x:.6f} <my>={avg_y:.6f} <mz>={avg_z:.6f}\n")
        for theta, phi, *_ in easy_axes:
            # loop.py expects at least 6 columns; the 4th column is a dummy (unused)
            f.write(f"{theta:.8f} {phi:.8f} {K1:.6e} 0.0 {Js:.6e} {A:.6e}\n")

def main():
    ap = argparse.ArgumentParser(
        description="Create a .krn file with random easy axes satisfying three volume-averaged conditions."
    )
    ap.add_argument("--mesh", required=True, help="Path to mesh .npz (knt, ijk) produced by mesh.py")
    ap.add_argument("--K1", type=float, default=0.7e6, help="Anisotropy constant K1 [J/m^3]")
    ap.add_argument("--Js", type=float, default=0.8, help="Saturation polarization Js [T]")
    ap.add_argument("--A",  type=float, default=7.6e-11, help="Exchange constant A [J/m]")
    ap.add_argument("--tol", type=float, default=0.001, help="Tolerance for averages vs 0.5")
    ap.add_argument("--out", type=str, default="combined.krn", help="Output .krn path")
    ap.add_argument("--max-attempts", type=int, default=20000, help="Maximum random trials")
    ap.add_argument("--seed", type=int, default=None, help="Random seed (optional)")
    args = ap.parse_args()

    # Load mesh
    knt, conn, mat_id = load_mesh(args.mesh)
    # Sanity: mat_id should start at 1 and be contiguous
    gmin, gmax = int(mat_id.min()), int(mat_id.max())
    if gmin != 1:
        print(f"[warn] mat_id minimum is {gmin}, expected 1. Proceeding but check your mesh.")
    print(f"[info] Mesh loaded: grains={gmax} (IDs {gmin}..{gmax}), elements={conn.shape[0]:,d}")

    # Generate accepted distribution
    easy_axes, (avg_x, avg_y, avg_z), attempts = generate_distribution_all_three(
        knt, conn, mat_id, tol=args.tol, max_attempts=args.max_attempts, seed=args.seed
    )

    # Write .krn with a small header
    write_krn(
        path=args.out,
        easy_axes=easy_axes,
        K1=args.K1,
        Js=args.Js,
        A=args.A,
        summary=(avg_x, avg_y, avg_z, attempts),
    )
    print(f"[ok] Wrote {args.out}")

if __name__ == "__main__":
    main()

